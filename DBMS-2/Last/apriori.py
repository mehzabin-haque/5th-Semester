# -*- coding: utf-8 -*-
"""Apriori with Count of product.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ETDVmB2A42H7cMsSFln967O1hP9nxU8I
"""

import joblib

transactions = [ [{"BREAD": 4, "COFFEE": 2, "SUGER": 5}],
 [{"BREAD": 3, "COFFEE": 2, "SUGER": 9}],
 [{"BREAD": 1, "TEA": 1, "BOURNVITA": 1}],
 [{"BREAD": 1, "JAM": 1, "MAGGI": 1, "MILK": 1}],
 [{"BISCUIT": 1, "TEA": 1, "MAGGI": 1}],
 [{"BREAD": 1, "TEA": 1, "BOURNVITA": 1}],
 [{"BISCUIT": 1, "TEA": 1, "MAGGI": 1}],
 [{"BISCUIT": 1, "BREAD": 2, "TEA": 1, "MAGGI": 1}],
 [{"JAM": 1, "BREAD": 1, "MAGGI": 1, "TEA": 1}],
 [{"BREAD": 1, "MILK": 1}],
 [{"BISCUIT": 1, "COCK": 2, "CORNFLAKES": 1, "COFFEE": 1}],
 [{"CORNFLAKES": 1, "BISCUIT": 2, "COCK": 2, "COFFEE": 1}],
 [{"SUGER": 1, "BOURNVITA": 1, "COFFEE": 1}],
 [{"BREAD": 1, "COCK": 1, "COFFEE": 1}],
 [{"BISCUIT": 1, "SUGER": 1, "BREAD": 1}],
 [{"CORNFLAKES": 1, "SUGER": 1, "COFFEE": 1}],
 [{"SUGER": 1, "BOURNVITA": 1, "BREAD": 1}],
 [{"BREAD": 1, "COFFEE": 1, "SUGER": 1}],
 [{"BREAD": 1, "COFFEE": 1, "SUGER": 1}],
 [{"CORNFLAKES": 1, "TEA": 1, "MILK": 1, "COFFEE": 1}]
]


joblib.dump(transactions, 'data.sav')

"""### Code Starts Here"""

transactions = joblib.load('data.sav')

from itertools import combinations

def getItemList(transactions):
    unique_items = []
    for transaction in transactions:
      for item in transaction[0]:
        if item not in unique_items:
          unique_items.append(item);
    unique_items.sort()
    return unique_items
# print(getItemList(transactions))

def pruneBasedOnSubset(ci, old_Li): # deleted the parameter "transaction"
  temp = ci.copy()
  all_itemset = list(old_Li.keys())

  for candidate in temp.keys():
      for subset in combinations(candidate, len(list(ci.keys())[0])-1):
          if list(subset) not in all_itemset:
              if len(list(ci.keys())[0])-1 != 1:
                # print("Pruning ["+str(candidate)+"] for its subset: {"+ str(subset) +"}")
                del ci[candidate]
                break
  return ci

#{frozenset({'MAGGI', 'BREAD', 'BOURNVITA', 'TEA'}): 0, frozenset({'MAGGI', 'BREAD', 'JAM', 'TEA'}): 1, frozenset({'MAGGI', 'BREAD', 'BISCUIT', 'TEA'}): 1, frozenset({'CORNFLAKES', 'BISCUIT', 'COCK', 'COFFEE'}): 2}

def initialize(treansactions, support_vector):
    unique_items = getItemList(transactions)

    C1 = {}
    for item in unique_items:
        for transaction in transactions:
            if item in transaction[0].keys():
                if item in C1.keys():
                    C1[item]+=getMinimumAmount(transaction[0])
                else: C1[item] = 1
    L1 = {}
    for item,count in zip(C1.keys(), C1.values()):
        if count>=support_vector:
            if item in L1: L1[frozenset([item])]+=count
            else: L1[frozenset([item])] = count
    return C1, L1

def joinItems(Li, item_size):
    old_items = [item for item in Li.keys()]
    new_items = []
    for i in range(0, len(old_items)):
        for j in range(i+1, len(old_items)):
            new_item = old_items[i].union(old_items[j])
            if(len(new_item)==item_size):
                new_items.append(new_item)

    new_items.sort()
    return new_items

'''
def countItemOccurence(items, transactions):
  Ci = {}
  for item in items:
      Ci[item] = 0
      for transaction in transactions:
          temp = set(transaction[0].keys())
          if(item.issubset(temp)):
              Ci[item]+=transaction[0][item]
  return Ci
  '''

def getMinimumAmount(itemDict):
  minValue = 100
  for item, value in itemDict.items():
    if value<minValue: minValue = value
  return minValue

def countItemOccurence(items, transactions):
  Ci = {}
  for item in items:
      Ci[item] = 0
      for transaction in transactions:
          itemDict = transaction[0]
          if item.issubset(set(itemDict.keys())):
            minValue = getMinimumAmount(itemDict)
            # print("DEBUG: "+str(minValue))
            Ci[item]+=minValue
  return Ci

#{frozenset({'MAGGI', 'BREAD', 'BOURNVITA', 'TEA'}): 0, frozenset({'MAGGI', 'BREAD', 'JAM', 'TEA'}): 1, frozenset({'MAGGI', 'BREAD', 'BISCUIT', 'TEA'}): 1, frozenset({'CORNFLAKES', 'BISCUIT', 'COCK', 'COFFEE'}): 2}

def aprioriAlgorithm(transactions, support_vector):
    C1, L1 = initialize(transactions, support_vector)
    # print("Set of Candidate 1-itemset, C1: \n"+str(C1)+"\n")
    # print("Set of frequen 1-itemset, L1: \n"+str(L1)+"\n")

    Li = L1 # Initializing
    Ci = C1

    total_result = []
    total_result.append(L1)
    for item_size in range(2,1000):
        Ci = countItemOccurence(joinItems(Li, item_size), transactions)
        # print("Candidate Set. C"+str(item_size)+":\n"+str(Ci)+"\n")

        Ci = pruneBasedOnSubset(Ci, Li)

        # Pruning, Li
        Li = {}
        for item in Ci:
            if Ci[item] >= support_vector:
                Li[item] = Ci[item]
        print("Accepted itemset, L"+str(item_size)+":\n"+str(Li)+"\n")

        total_result.append(Li)
        if(len(Li)==0): return total_result

"""### Testing"""

transactions = joblib.load('data.sav')
print("Final Answer:\n"+str(aprioriAlgorithm(transactions, support_vector=2)))

"""### Testing"""

"""# Query"""

def confidence(A, B, transactions):
    lob = union(A,B)
    lob_count = 0
    hor = A
    hor_count = 0
    
    for transaction in transactions:
      item = transaction[0].keys()
      if set(lob).issubset(set(item)):
          lob_count += getMinimumAmount(transaction[0])
      if set(hor).issubset(set(item)):
          hor_count += getMinimumAmount(transaction[0])
    if hor_count ==0: confidence = 0
    else: confidence = (lob_count/hor_count)*100
    print(str(A)+"==>"+str(B)+" confidence is: "+str(confidence)+"%")
                

def union(A,B):
    lob = []
    for item in A:
        if item not in lob:
            lob.append(item)
    for item in B:
        if item not in lob:
            lob.append(item)
    return lob
        

confidence(["BREAD", "COFFEE"], ["SUGER"], transactions)
confidence(["BREAD"], ["SUGER", "COFFEE"], transactions)

